import argparse
import multiprocessing
import os
import re
from ast import (
    AST,
    AsyncFunctionDef,
    ClassDef,
    Constant,
    Expr,
    FunctionDef,
    NodeTransformer,
    get_docstring,
    iter_child_nodes,
    parse,
    unparse,
)
from typing import Union

from ollama import generate
from tqdm import tqdm


def count_nodes(node: AST) -> int:
    """
    Returns the number of nodes in the Abstract Syntax Tree (AST) that have no docstrings.

    This function is designed to be used with an AST generated by the `ast` module. It counts the number of nodes that are either ClassDefs, FunctionDefs, or AsyncFunctionDefs and do not have a docstring.

    Args:
        node: The root node of the AST

    Returns:
        An integer representing the count of nodes without docstrings
    """
    return sum(
        (
            isinstance(child, (ClassDef, FunctionDef, AsyncFunctionDef))
            and (not get_docstring(child))
            for child in iter_child_nodes(node)
        )
    )


class DocstringGenerator(NodeTransformer):
    """
    A NodeTransformer that generates docstrings for Python nodes.

    This class takes in a model, prompt, and progress bar, and uses them to
    generate docstrings for class definitions, functions, and asynchronous
    functions. The generated docstrings are then added to the node's body.

    Attributes:
        model: A string representing the AI model used for generating docstrings.
        prompt: A string representing the initial prompt used to generate
            docstrings.
        pbar: A tqdm progress bar object used to track progress during
            generation.

    Methods:
        extract_docstring(text): Extracts a docstring from a given text.
        add_docstring(node): Adds a generated docstring to a node's body.
        visit(node): Visits a node and adds a docstring if necessary.
    """

    def __init__(self, model: str, prompt: str, pbar: tqdm):
        """Initializes a new instance of this class.

        Args:
            model (str): The model to use.
            prompt (str): The prompt to generate text for.
            pbar (tqdm): A progress bar object used to display the generation progress.

        Returns:
            None
        """
        self.model = model
        self.prompt = prompt
        self.pbar = pbar

    def extract_docstring(self, text: str) -> str:
        """
        Extracts the docstring from the given text.

        Args:
            self: The instance of the class.
            text: The input text to extract the docstring from.

        Returns:
            A string representing the extracted docstring. If no docstring is found, returns None.

        """
        pattern = '"""(.*?)"""'
        matches = re.findall(pattern, text, re.DOTALL)
        return matches[0] if matches else ""

    def add_docstring(
        self, node: Union[ClassDef, FunctionDef, AsyncFunctionDef]
    ) -> Union[ClassDef, FunctionDef, AsyncFunctionDef]:
        """Adds a generated docstring to the given node (class or function).

        Args:
            self (object): The current object.
            node (Union[ClassDef, FunctionDef, AsyncFunctionDef]): The class or function definition node.

        Returns:
            Union[ClassDef, FunctionDef, AsyncFunctionDef]: The modified node with the generated docstring.
        """
        prompt = self.prompt + unparse(node)
        response = generate(model=self.model, prompt=prompt)
        docstring = Expr(
            value=Constant(value=self.extract_docstring(response["response"]))
        )
        node.body.insert(0, docstring)
        self.pbar.update()
        return node

    def visit(self, node: AST) -> AST:
        """
        Visit a node in an AST and add a docstring if necessary.

        Args:
          self: The current visitor object.
          node (AST): The node to visit.

        Returns:
          AST: The visited node, possibly with a new docstring added.

        Notes:
          This method is used to add docstrings to class and function definitions
          in an Abstract Syntax Tree. If the node is a class or function definition
          and does not already have a docstring, this method will add one.
        """
        if isinstance(node, (ClassDef, FunctionDef, AsyncFunctionDef)) and (
            not get_docstring(node)
        ):
            return self.generic_visit(self.add_docstring(node))
        else:
            return self.generic_visit(node)


def handle_python_file(file_path: str, model: str, prompt: str) -> None:
    """
    Processes a Python file using a given model and prompt.

    Reads the source code from the file, parses it into an abstract syntax tree (AST),
    and then applies the specified model and prompt to generate new code. The processed
    AST is then written back to the original file.

    Args:
        file_path: The path to the Python file to process.
        model: The name of the model to use for code generation.
        prompt: The prompt to use when generating new code.

    Returns:
        None
    """
    with open(file_path) as file:
        source = file.read()
        tree = parse(source)
    pbar = tqdm(total=count_nodes(tree))
    pbar.set_description(f"Processing {file_path}")
    new_tree = DocstringGenerator(model, prompt, pbar).visit(tree)
    with open(file_path, "w") as file:
        file.write(unparse(new_tree))
    pbar.close()


def main() -> None:
    """
    Generate docstrings for Python files.

    This function uses argparse to parse command-line arguments and multiprocessing to process multiple Python files in parallel. It takes two optional arguments: --model, which specifies the model to use for generating docstrings, and --prompt, which specifies the prompt to use for generating docstrings.

    Args:
        None

    Returns:
        None
    """
    parser = argparse.ArgumentParser(
        description="Generate docstrings for Python files."
    )
    parser.add_argument(
        "--model",
        type=str,
        default="llama3",
        help="The model to use for generating docstrings.",
    )
    parser.add_argument(
        "--prompt",
        type=str,
        default="write a google styled docstring inside triple quotes for this python code: \n ",
        help="The prompt to use for generating docstrings.",
    )
    args = parser.parse_args()
    with multiprocessing.Pool() as pool:
        python_files = [
            os.path.join(root, file)
            for root, _, files in os.walk(".", topdown=True)
            for file in files
            if file.endswith(".py") and (not file.startswith("__"))
        ]
        for file in python_files:
            pool.apply_async(handle_python_file, (file, args.model, args.prompt))
        pool.close()
        pool.join()


if __name__ == "__main__":
    main()

